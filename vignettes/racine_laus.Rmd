---
title: "racine_laus"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{racine_laus}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
content_size <- c(width = 7, height = 4)
content_dpi <- 96
knitr::opts_chunk$set(
    collapse = TRUE,
    warning = FALSE,
    message = FALSE,
    comment = "#>",
    cache = TRUE,
    dpi = content_dpi,
    fig.dim = content_size
)

.random_rows <- c(266, 525, 947, 1246, 1691, 1989, 2631, 2704, 3370, 4009, 4303)

```

```{r setup}
library(hiRx)
library(magrittr)
library(rlang)

laus_data <- dplyr::bind_rows(hiRx::racine_laus) # condense the 3 tibbles to 1
```

## laus: **L**ocal **A**rea **U**nemployment **S**tatistics
The U.S. Bureau of Labor Statistics curates information about unemployment at a wide range of geographic scales.
These data are the Local Area Unemployment Statistics, or "LAUS."
For example, one can retrieve monthly information about the size of the labor force in:

* [the entire Midwest](https://beta.bls.gov/dataViewer/view/timeseries/LAURD920000000000006)
* [the State of Wisconsin](https://beta.bls.gov/dataViewer/view/timeseries/LAUST550000000000006)
* [Racine County](https://beta.bls.gov/dataViewer/view/timeseries/LAUCN551010000000006)
* [the City of Racine](https://beta.bls.gov/dataViewer/view/timeseries/LAUCT556600000000006)


There is even a [public API](https://www.bls.gov/developers/home.htm).

### Wrangling LAUS data

Downloading many data series from the LAUS API is slower than loading it from a local file.
To expedite this vignette, the `hiRx` package comes with a data set `racine_laus` that is a list of `tibble` objects for three areas:

* the City of Racine, WI
* Racine County
* the State of Wisconsin.

Each area has seasonally **UN**adjusted values for:

* the size of the Labor Force
* the number of people who are Employed
* the number of people who are Unemployed
* the Unemployment Rate

For the purposes of this vignette, the list `racine_laus` is converted to a single data fram, `laus_data`.
Here are 11 of its rows:

```{r built-in-data, echo = FALSE}
laus_data %>%
    dplyr::slice(.random_rows) %>%
    knitr::kable()

```

This format is not tidy because the `Series` variable contains the information in both the `Geography` and the `Measure` columns.
The `Geography` variable itself is a compound of several different levels of geography.
The `unlump_series` function is a crucial step in tidying these data by appropriately separating `Series` into several variables.
As you would expect from 3 geographies and 4 time series, the full `racine_laus` data set contains 12 distinct series:

```{r list-racine-series, echo = FALSE}
laus_data %>%
    dplyr::select(.data$Series) %>%
    dplyr::distinct() %>%
    dplyr::mutate(tmp = .data$Series) %>%
    unlump_series(.data$tmp) %>%
    knitr::kable()

```

In addition to separating variables, we need to define some human-readable translations for the FIPS codes in the data.

##### Labels for Geographic Areas

There are three unique geographies in our data set, so they each get a label.

```{r geo-labels}
location_labels <- tibble::tribble(
    ~ State, ~ Area, ~ Geography,
    "55", "00000000000", "Wisconsin",
    "55", "66000000000", "Racine City",
    "55", "10100000000", "Racine County"
)

```

##### Labels for Time Series

The four unique time series in our data set also need human-readable labels.

```{r measure-labels}
measure_labels <- tibble::tribble(
    ~ `Measure Code`, ~ Measure,
    "03", "Unemployment Rate",
    "04", "Unemployed",
    "05", "Employed",
    "06", "Labor Force",
    "07", "Employment:Population Ratio",
    "08", "Labor Force Participation Rate",
    "09", "Civilian Non-Institutional Population"
)

```

The `laus_tidy` function uses those mappings to create a new table in a more helpful format.
The resulting has one response variable, `Value`, and three grouping variables:

* A temporal variable, `Date`
* A spatial variables, `Geography`
* A variable that identifies the time series, `Measure`

```{r final-tidy}
laus_data <- laus_tidy(laus_data,
                       location_labels,
                       measure_labels)

laus_data %>%
    dplyr::slice(.random_rows) %>%
    knitr::kable()

```

### Visualizing LAUS data

Line graphs are the go-to visualization for time series data.
The four-column format of `laus_data` lends itself to a single graphing function.

```{r define-graphing-functions}
.count_uniques <- function(.x, .col) {
    .x %>%
        dplyr::pull({{ .col }}) %>%
        dplyr::n_distinct()
}

plot_lines_across <- function(.x, .x_col, .color, .ylabel, .yscale) {
    .x %>%
        ggplot2::ggplot(
            ggplot2::aes(x = {{ .x_col }},
                         y = .data$Value,
                         color = {{ .color }})
        ) +
        ggplot2::geom_line() +
        hiRx::scale_color_higher_ex(
            palette = "tableau",
            n.colors = .count_uniques(.x, {{ .color }})
        ) +
        ggplot2::scale_y_continuous(
            name = .ylabel,
            limits = c(0, NA),
            labels = .yscale
        ) +
        ggplot2::theme_bw() +
        ggplot2::theme(
            legend.position = "top",
            legend.title = ggplot2::element_blank()
        )
}

```

#### Monthly Changes

##### One Series across Several Areas

```{r compare-geographies-unemployment-rate}
laus_data %>%
    dplyr::filter(
        .data$Measure == "Unemployment Rate"
    ) %>%
    plot_lines_across(.data$Date,
                      .data$Geography,
                      "Unemployment Rate",
                      scales::label_percent(
                          accuracy = 1
                     ))
```

##### Several Series for One Area

```{r compare-measure-for-racine-city}
laus_data %>%
    dplyr::filter(
        .data$Geography == "Racine City",
        .data$Measure != "Unemployment Rate"
    ) %>%
    plot_lines_across(.data$Date,
                      .data$Measure,
                      "Number of People",
                      scales::label_comma())

```

#### Annual Changes

Personally, I think that the monthly variations distract from the year-to-year
trends. The obvious solution is to make annual averages.

```{r make-annual-averages}
annual_data <- laus_data %>%
    dplyr::group_by(
        Year = lubridate::year(.data$Date),
        .data$Geography,
        .data$Measure
    ) %>%
    dplyr::summarize(
        Value = mean(.data$Value)
    ) %>%
    dplyr::ungroup()

```

This summary results in smoother visualizations:

##### One Series across Several Areas

```{r plot-annual-unemployments}
annual_data %>%
    dplyr::filter(
        .data$Measure == "Unemployment Rate"
    ) %>%
    plot_lines_across(.data$Year,
                      .data$Geography,
                      "Unemployment Rate",
                      scales::label_percent(accuracy = 1))
```

##### Several Series for One Area

```{r plot-annual-measures-for-racine-city}
annual_data %>%
    dplyr::filter(
        .data$Geography == "Racine City",
        .data$Measure != "Unemployment Rate"
    ) %>%
    plot_lines_across(.data$Year,
                      .data$Measure,
                      "Number of People",
                      scales::label_comma())

```

